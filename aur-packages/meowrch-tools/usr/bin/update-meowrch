#!/bin/bash
#
# Meowrch Update Checker - update management system
#

set -euo pipefail

# Constants
readonly GITHUB_API_URL="https://api.github.com/repos/meowrch/meowrch/releases"
readonly VERSION_FILE="/usr/local/share/meowrch/users/$(whoami)/version"
readonly NOTIFICATION_STATE="$HOME/.local/state/meowrch-notifications"

# Colors
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly RED='\033[0;31m'
readonly NC='\033[0m'

# Output functions
log() {
    echo -e "${GREEN}[INFO]${NC} $1" >&2
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Get current version
get_current_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        echo "2.0.0"  # Default
    fi
}

# Get latest version from GitHub
get_latest_version() {
    curl -s "$GITHUB_API_URL" | jq -r '.[0].tag_name' | sed 's/^v//'
}

# Find latest version with migration file
get_latest_version_with_migration() {
    local releases
    releases=$(curl -s "$GITHUB_API_URL")
    
    # Iterate through releases from newest to oldest and find first one with migration file
    for version in $(echo "$releases" | jq -r '.[].tag_name' | sed 's/^v//'); do
        local migration_exists
        migration_exists=$(echo "$releases" | jq --arg version "v$version" --arg version_no_v "$version" --arg filename "migrate_to_$version.py" '
            .[] | select(.tag_name == $version or .tag_name == $version_no_v) | 
            .assets[] | select(.name == $filename) | .name'
        )
        
        if [[ -n "$migration_exists" ]]; then
            echo "$version"
            return 0
        fi
    done
    
    # If no version with migration found
    return 1
}

# Get all releases, sorted by version
get_all_releases() {
    curl -s "$GITHUB_API_URL" | jq -r '.[].tag_name' | sed 's/^v//' | sort -V
}

# Set version
set_version() {
    local version="$1"
    sudo mkdir -p "$(dirname "$VERSION_FILE")"
    echo "$version" | sudo tee "$VERSION_FILE" > /dev/null
    log "✅ Version updated to $version"
}

# Version comparison (v1 > v2) - returns 0 (true) only when v1 is strictly greater than v2
version_gt() {
    # Return false if versions are equal
    [[ "$1" == "$2" ]] && return 1
    # Return true if v1 > v2 (sequence is already sorted)
    printf '%s\n%s\n' "$2" "$1" | sort -V -C
}

# Show migration file contents to user
show_migration_preview() {
    local migration_file="$1"
    local version="$2"
    
    log "📋 Previewing migration file migrate_to_$version.py"
    log "💡 Use arrows to navigate, 'q' to exit preview"
    echo "" >&2
    
    # Create temporary file with header for nice display
    local temp_preview="/tmp/migration-preview-$$"
    {
        echo "==================== MIGRATION PREVIEW ===================="
        echo "File: migrate_to_$version.py"
        echo "Version: $version"
        echo "=========================================================="
        echo ""
        cat "$migration_file"
        echo ""
        echo "=========================================================="
    } > "$temp_preview"
    
    # Show file through less with paru-like settings
    if command -v less > /dev/null 2>&1; then
        # less settings:
        # -R: display ANSI colors
        # -S: don't wrap long lines
        # -F: automatically exit if content fits on screen
        # -X: don't clear screen on exit
        # +Gg: go to end of file and show line number
        export LESS="-R -S -F -X"
        
        # Show preview through less
        less "$temp_preview"
    else
        # Fallback for systems without less
        warn "less not found, showing content through cat"
        cat "$temp_preview" >&2
    fi
    
    # Remove temporary file
    rm -f "$temp_preview"
    
    echo "" >&2
    
    # Ask user about continuing
    while true; do
        echo -ne "${YELLOW}==> Continue with migration execution? [Y/n]: ${NC}" >&2
        read -r response
        case "$response" in
            ""|[Yy]|[Yy][Ee][Ss])
                return 0
                ;;
            [Nn]|[Nn][Oo])
                return 1
                ;;
            *)
                echo -e "${RED}Please enter Y (yes) or N (no)${NC}" >&2
                ;;
        esac
    done
}

# Download and execute migration
run_migration() {
    local version="$1"
    local temp_dir="/tmp/meowrch-update-$version"
    
    # Remove old folder if exists
    rm -rf "$temp_dir"
    mkdir -p "$temp_dir"
    
    log "🔄 Checking update to version $version..."
    
    # Get release data (try both with v prefix and without)
    local release_data
    release_data=$(curl -s "$GITHUB_API_URL" | jq --arg version "v$version" --arg version_no_v "$version" '.[] | select(.tag_name == $version or .tag_name == $version_no_v)')
    
    if [[ -z "$release_data" || "$release_data" == "null" ]]; then
        error "Release version $version not found"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # FIRST check if migration file exists
    local migration_download_url
    migration_download_url=$(echo "$release_data" | jq -r --arg filename "migrate_to_$version.py" '.assets[] | select(.name == $filename) | .browser_download_url')
    
    if [[ -z "$migration_download_url" || "$migration_download_url" == "null" ]]; then
        log "📝 Migration file migrate_to_$version.py not found for version $version"
        log "⏭️ Skipping this version (version NOT updated)"
        rm -rf "$temp_dir"
        return 0
    fi
    
    # Only if migration file exists - download archive
    log "✅ Found migration file for version $version"
    
    # Get URL of TAR.GZ archive of release (tarball is usually smaller)
    local tarball_url
    tarball_url=$(echo "$release_data" | jq -r '.tarball_url')
    
    if [[ -z "$tarball_url" || "$tarball_url" == "null" ]]; then
        error "TAR.GZ archive for version $version not found"
        rm -rf "$temp_dir"
        return 1
    fi
    
    log "📦 Downloading TAR.GZ archive of release $version..."
    local tar_file="$temp_dir/release.tar.gz"
    
    # Download with progress bar if supported
    if [[ -t 2 ]]; then  # Check that stderr is a terminal
        if ! curl -L --progress-bar "$tarball_url" -o "$tar_file"; then
            error "Failed to download TAR.GZ archive of release"
            rm -rf "$temp_dir"
            return 1
        fi
    else
        # Without progress bar for scripts/automation
        if ! curl -L -s "$tarball_url" -o "$tar_file"; then
            error "Failed to download TAR.GZ archive of release"
            rm -rf "$temp_dir"
            return 1
        fi
    fi
    
    log "📂 Extracting archive..."
    if ! tar -xzf "$tar_file" -C "$temp_dir"; then
        error "Failed to extract TAR.GZ archive"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Find extracted folder (GitHub creates folder like username-reponame-commitid)
    # Exclude the parent temp_dir folder itself
    local extracted_dir
    extracted_dir=$(find "$temp_dir" -maxdepth 1 -type d -name "*meowrch*" ! -path "$temp_dir" | head -n1)
    
    if [[ -z "$extracted_dir" ]]; then
        error "Failed to find extracted release folder"
        log "Contents of $temp_dir:"
        ls -la "$temp_dir" >&2
        rm -rf "$temp_dir"
        return 1
    fi
    
    log "🔄 Found extracted folder: $(basename "$extracted_dir")"
    
    # Rename to standard name
    mv "$extracted_dir" "$temp_dir/meowrch"
    
    log "📥 Downloading migration file..."
    local migration_file="$temp_dir/meowrch/migrate_to_$version.py"
    if ! curl -L -s "$migration_download_url" -o "$migration_file"; then
        error "Failed to download migration file"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Show migration contents to user
    if ! show_migration_preview "$migration_file" "$version"; then
        warn "Migration cancelled by user"
        rm -rf "$temp_dir"
        return 1
    fi
    
    log "🔄 Executing migration to version $version..."
    
    # Go to release folder for migration execution
    cd "$temp_dir/meowrch" || {
        error "Failed to change to release folder"
        rm -rf "$temp_dir"
        return 1
    }
    
    # Execute migration
    if python3 "migrate_to_$version.py"; then
        log "✅ Migration to version $version completed successfully"
        set_version "$version"
    else
        error "Migration to version $version failed"
        cd - > /dev/null
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Return to original directory
    cd - > /dev/null
    rm -rf "$temp_dir"
    return 0
}


# Check if notification was shown for version
is_version_notified() {
    local version="$1"
    [[ -f "$NOTIFICATION_STATE" ]] && grep -q "^$version$" "$NOTIFICATION_STATE"
}

# Mark version as notified
mark_version_notified() {
    local version="$1"
    mkdir -p "$(dirname "$NOTIFICATION_STATE")"
    echo "$version" >> "$NOTIFICATION_STATE"
}

# Mark version as hidden (don't show notifications)
mark_version_hidden() {
    local version="$1"
    local hidden_file="$HOME/.local/state/meowrch-hidden"
    mkdir -p "$(dirname "$hidden_file")"
    echo "$version" >> "$hidden_file"
}

# Check if version is hidden by user
is_version_hidden() {
    local version="$1"
    local hidden_file="$HOME/.local/state/meowrch-hidden"
    [[ -f "$hidden_file" ]] && grep -q "^$version$" "$hidden_file"
}

# Start update in new terminal
open_update_terminal() {
    # Terminal list for Meowrch in order of preference
    local terminals=(
        "kitty"             # Main terminal in Meowrch
        "alacritty"         # Alternative modern
        "gnome-terminal"    # GNOME compatibility
        "xterm"             # Fallback
    )
    
    # Find available terminal
    local terminal_cmd=""
    local terminal_name=""
    for terminal in "${terminals[@]}"; do
        if command -v "$terminal" > /dev/null 2>&1; then
            terminal_name="$terminal"
            case "$terminal" in
                "kitty"|"alacritty")
                    terminal_cmd="$terminal -e"
                    ;;
                "gnome-terminal")
                    terminal_cmd="$terminal --"
                    ;;
                "xterm")
                    terminal_cmd="xterm -e"
                    ;;
            esac
            break
        fi
    done
    
    if [[ -z "$terminal_cmd" ]]; then
        error "No suitable terminal emulator found"
        log "💡 Run update manually: update-meowrch update"
        return 1
    fi
    
    log "🖥️ Opening terminal for update ($terminal_name)..."
    
    # Create temporary script for nice terminal output
    local temp_script="/tmp/meowrch-update-terminal-$$"
    local script_path="$(which update-meowrch 2>/dev/null || echo "/usr/bin/update-meowrch")"
    
    # Use current script if not found in PATH
    if [[ "$script_path" == "/usr/bin/update-meowrch" ]] && [[ ! -f "$script_path" ]]; then
        script_path="${0}"
    fi
    
    # Escape script_path variable for use in heredoc
    local script_path_escaped="${script_path}"
    
    cat > "$temp_script" << 'EOF'
#!/bin/bash
set -e

# Update script path
SCRIPT_PATH="@SCRIPT_PATH@"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${CYAN}             🔄 MEOWRCH SYSTEM UPDATE 🔄${NC}"
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo ""
echo -e "${YELLOW}Starting update process...${NC}"
echo ""

# Run update
if "${SCRIPT_PATH}" update; then
    echo ""
    echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}             ✅ UPDATE COMPLETED SUCCESSFULLY! ✅${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${GREEN}🎉 Meowrch has been successfully updated!${NC}"
    echo -e "${YELLOW}💡 It's recommended to reboot the system to apply all changes${NC}"
else
    echo ""
    echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${RED}             ❌ UPDATE ERROR! ❌${NC}"
    echo -e "${RED}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
    echo -e "${RED}💥 An error occurred during update${NC}"
    echo -e "${YELLOW}💡 Check logs above or run '${SCRIPT_PATH} status' for diagnostics${NC}"
fi

echo ""
echo -e "${BLUE}Press Enter to close terminal...${NC}"
read

# Remove temporary script
rm -f "$0"
EOF
    
    # Replace @SCRIPT_PATH@ marker with real script path
    sed -i "s|@SCRIPT_PATH@|${script_path_escaped}|g" "$temp_script"
    
    chmod +x "$temp_script"
    
    # Run in background
    nohup $terminal_cmd bash "$temp_script" > /dev/null 2>&1 &
    
    log "✅ Terminal with update started"
}

notify_user() {
    local latest_version="$1"
    local current_version="$2"
    
    # Determine icon
    local icon_arg=""
    if [[ -f "/usr/share/pixmaps/meowrch-logo.png" ]]; then
        icon_arg="-i /usr/share/pixmaps/meowrch-logo.png"
    else
        icon_arg="-i software-update-available"
    fi
    
    # Desktop notification with buttons
    if command -v notify-send > /dev/null 2>&1; then
        # Check action support in notify-send
        if notify-send --help 2>/dev/null | grep -q -- "--action"; then
            # Modern version with button support
            local result
            result=$(notify-send \
                --app-name="Meowrch" \
                "New version available!" \
                "Version $latest_version is ready to install.\nTo update run: update-meowrch update" \
                $icon_arg \
                --urgency="critical" \
                --expire-time=0 \
                --action="update=Update now" \
                --action="hide=Don't show again" \
                --action="later=Remind later" 2>/dev/null || echo "")
            
            # Handle user response
            case "$result" in
                "update")
                    log "🚀 User started update from notification"
                    open_update_terminal
                    ;;
                "hide")
                    log "🔕 User hid notifications for version $latest_version"
                    mark_version_hidden "$latest_version"
                    ;;
                "later"|"")
                    log "⏰ User postponed update"
                    ;;
            esac
        else
            # Simple notification without buttons
            notify-send \
                --app-name="Meowrch" \
                "🔄 New Meowrch version!" \
                "Version $latest_version available (current: $current_version)\n\nTo update: update-meowrch update" \
                $icon_arg \
                --urgency="critical" \
                --expire-time=0
        fi
    fi
    
    log "🆕 New version available: $latest_version (current: $current_version)"
    log "💡 To update use: update-meowrch update"
}

check_update() {
    local current_version
    current_version=$(get_current_version)
    
    log "Checking for updates... (current version: $current_version)"
    
    local latest_with_migration
    latest_with_migration=$(get_latest_version_with_migration)
    
    if [[ -z "$latest_with_migration" ]]; then
        log "✅ No updates available (no versions with migration files)"
        return 0
    fi
    
    # Only notify if there's a newer version available
    if version_gt "$latest_with_migration" "$current_version"; then
        # Check if version is hidden by user
        if is_version_hidden "$latest_with_migration"; then
            log "ℹ️ Notifications for version $latest_with_migration are hidden by user"
            return 0
        fi
        
        # Check if notification was already shown (but only if not hidden)
        if is_version_notified "$latest_with_migration"; then
            # Show notification again, as user didn't hide it
            log "🔄 Showing repeated notification for version $latest_with_migration"
            notify_user "$latest_with_migration" "$current_version"
        else
            # First time showing notification
            log "🆕 Showing notification about new version $latest_with_migration"
            notify_user "$latest_with_migration" "$current_version"
            mark_version_notified "$latest_with_migration"
        fi
    else
        log "✅ You have the latest available version ($current_version)"
    fi
}

# Show current version status
show_status() {
    local current_version
    current_version=$(get_current_version)
    local latest_version
    latest_version=$(get_latest_version)
    local latest_with_migration
    latest_with_migration=$(get_latest_version_with_migration)
    
    log "📋 Current version: $current_version"
    log "📋 Latest version on GitHub: $latest_version"
    
    if [[ -n "$latest_with_migration" ]]; then
        log "📋 Latest version with migration: $latest_with_migration"
        
        if [[ "$current_version" == "$latest_with_migration" ]]; then
            log "✅ You have the latest version with available updates"
        elif version_gt "$latest_with_migration" "$current_version"; then
            log "🆕 Update available to version $latest_with_migration"
        else
            log "ℹ️ Your version is newer than the latest version with migration"
        fi
    else
        log "ℹ️ No available versions with migration files"
    fi
}

# Perform update
perform_update() {
    local current_version
    current_version=$(get_current_version)
    
    # Now update only to latest version with migration
    local target_version
    target_version=$(get_latest_version_with_migration)
    
    if [[ -z "$target_version" ]]; then
        warn "No available versions with migration files"
        return 0
    fi

    log "🔄 Updating from $current_version to $target_version"

    if [[ "$current_version" == "$target_version" ]]; then
        log "✅ Version $target_version is already installed"
        return 0
    fi
    
    if ! version_gt "$target_version" "$current_version"; then
        log "ℹ️ Your version ($current_version) is not older than latest available ($target_version)"
        return 0
    fi

    log "📋 Direct update: $current_version → $target_version"
    
    # Try to run migration
    if run_migration "$target_version"; then
        log "✅ Update completed successfully: $current_version → $target_version"
    else
        error "❌ Update failed"
        return 1
    fi
}

# Main functionality
case "${1:-status}" in
    "check")
        check_update
        ;;
    "status")
        show_status
        ;;
    "update")
        perform_update
        ;;
    "open-terminal")
        open_update_terminal
        ;;
    *)
        echo "Usage: update-meowrch [check|status|update|open-terminal]"
        echo ""
        echo "Commands:"
        echo "  check         - Check for updates and show notification if available"
        echo "  status        - Show current version status"
        echo "  update        - Update to the latest version with migration"
        echo "  open-terminal - Open update in new terminal window"
        echo ""
        echo "Default command is 'check' when no arguments provided"
        ;;
esac
