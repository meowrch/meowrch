#!/bin/bash
#
# Meowrch Update Checker - update management system
#

set -euo pipefail

# Constants
readonly GITHUB_API_URL="https://api.github.com/repos/meowrch/meowrch/releases"
readonly VERSION_FILE="/usr/local/share/meowrch/users/$(whoami)/version"
readonly NOTIFICATION_STATE="$HOME/.local/state/meowrch-notifications"

# Colors
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly RED='\033[0;31m'
readonly NC='\033[0m'

# Output functions
log() {
    echo -e "${GREEN}[INFO]${NC} $1" >&2
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Get current version
get_current_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        echo "2.0.0"  # Default
    fi
}

# Get latest version from GitHub
get_latest_version() {
    curl -s "$GITHUB_API_URL" | jq -r '.[0].tag_name' | sed 's/^v//'
}

# Find latest version with migration file
get_latest_version_with_migration() {
    local releases
    releases=$(curl -s "$GITHUB_API_URL")
    
    # Iterate through releases from newest to oldest and find first one with migration file
    for version in $(echo "$releases" | jq -r '.[].tag_name' | sed 's/^v//'); do
        local migration_exists
        migration_exists=$(echo "$releases" | jq --arg version "v$version" --arg version_no_v "$version" --arg filename "migrate_to_$version.py" '
            .[] | select(.tag_name == $version or .tag_name == $version_no_v) | 
            .assets[] | select(.name == $filename) | .name'
        )
        
        if [[ -n "$migration_exists" ]]; then
            echo "$version"
            return 0
        fi
    done
    
    # If no version with migration found
    return 1
}

# –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –≤–µ—Ä—Å–∏–π —Å –º–∏–≥—Ä–∞—Ü–∏—è–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–æ–≤–µ–µ —Ç–µ–∫—É—â–µ–π
get_versions_with_migrations() {
    local current_version="$1"
    local target_version="${2:-}"  # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è —Ü–µ–ª–µ–≤–∞—è –≤–µ—Ä—Å–∏—è
    
    local releases
    releases=$(curl -s "$GITHUB_API_URL")
    
    local versions=()
    while IFS= read -r version; do
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–µ—Ä—Å–∏–∏ —Å—Ç–∞—Ä–µ–µ –∏–ª–∏ —Ä–∞–≤–Ω—ã–µ —Ç–µ–∫—É—â–µ–π
        if ! version_gt "$version" "$current_version"; then
            continue
        fi
        
        # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞ —Ü–µ–ª–µ–≤–∞—è –≤–µ—Ä—Å–∏—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–µ—Ä—Å–∏–∏ –Ω–æ–≤–µ–µ —Ü–µ–ª–µ–≤–æ–π
        if [[ -n "$target_version" ]] && version_gt "$version" "$target_version"; then
            continue
        fi
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–∏–≥—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ (–ª—é–±–æ–≥–æ —Ç–∏–ø–∞)
        local migration_exists
        migration_exists=$(echo "$releases" | jq -r --arg version "v$version" --arg version_no_v "$version" --arg full_filename "migrate_to_$version.py" --arg light_filename "migrate_to_${version}_light.py" '
            .[] | select(.tag_name == $version or .tag_name == $version_no_v) | 
            .assets[] | select(.name == $full_filename or .name == $light_filename) | .name'
        )
        
        if [[ -n "$migration_exists" ]]; then
            versions+=("$version")
        fi
    done < <(echo "$releases" | jq -r '.[].tag_name' | sed 's/^v//' | sort -V)
    
    printf '%s\n' "${versions[@]}"
}

# A new function for determining the migration type
get_migration_type() {
    local version="$1"
    local releases
    releases=$(curl -s "$GITHUB_API_URL")
    
    # Checking for easy migration
    local light_migration
    light_migration=$(echo "$releases" | jq -r --arg version "v$version" --arg version_no_v "$version" --arg filename "migrate_to_${version}_light.py" '
        .[] | select(.tag_name == $version or .tag_name == $version_no_v) | 
        .assets[] | select(.name == $filename) | .name'
    )
    
    if [[ -n "$light_migration" ]]; then
        echo "light"
        return 0
    fi
    
    # Checking for a full migration
    local full_migration
    full_migration=$(echo "$releases" | jq -r --arg version "v$version" --arg version_no_v "$version" --arg filename "migrate_to_$version.py" '
        .[] | select(.tag_name == $version or .tag_name == $version_no_v) | 
        .assets[] | select(.name == $filename) | .name'
    )
    
    if [[ -n "$full_migration" ]]; then
        echo "full"
        return 0
    fi
    
    return 1
}

# Get all releases, sorted by version
get_all_releases() {
    curl -s "$GITHUB_API_URL" | jq -r '.[].tag_name' | sed 's/^v//' | sort -V
}

# Set version
set_version() {
    local version="$1"
    sudo mkdir -p "$(dirname "$VERSION_FILE")"
    echo "$version" | sudo tee "$VERSION_FILE" > /dev/null
    log "‚úÖ Version updated to $version"
}

# Version comparison (v1 > v2) - returns 0 (true) only when v1 is strictly greater than v2
version_gt() {
    # Return false if versions are equal
    [[ "$1" == "$2" ]] && return 1
    # Return true if v1 > v2 (sequence is already sorted)
    printf '%s\n%s\n' "$2" "$1" | sort -V -C
}

# Show migration file contents to user
show_migration_preview() {
    local migration_file="$1"
    local version="$2"
    
    log "üìã Previewing migration file migrate_to_$version.py"
    log "üí° Use arrows to navigate, 'q' to exit preview"
    echo "" >&2
    
    # Create temporary file with header for nice display
    local temp_preview="/tmp/migration-preview-$$"
    {
        echo "==================== MIGRATION PREVIEW ===================="
        echo "File: migrate_to_$version.py"
        echo "Version: $version"
        echo "=========================================================="
        echo ""
        cat "$migration_file"
        echo ""
        echo "=========================================================="
    } > "$temp_preview"
    
    # Show file through less with paru-like settings
    if command -v less > /dev/null 2>&1; then
        # less settings:
        # -R: display ANSI colors
        # -S: don't wrap long lines
        # -F: automatically exit if content fits on screen
        # -X: don't clear screen on exit
        # +Gg: go to end of file and show line number
        export LESS="-R -S -F -X"
        
        # Show preview through less
        less "$temp_preview"
    else
        # Fallback for systems without less
        warn "less not found, showing content through cat"
        cat "$temp_preview" >&2
    fi
    
    # Remove temporary file
    rm -f "$temp_preview"
    
    echo "" >&2
    
    # Ask user about continuing
    while true; do
        echo -ne "${YELLOW}==> Continue with migration execution? [Y/n]: ${NC}" >&2
        read -r response
        case "$response" in
            ""|[Yy]|[Yy][Ee][Ss])
                return 0
                ;;
            [Nn]|[Nn][Oo])
                return 1
                ;;
            *)
                echo -e "${RED}Please enter Y (yes) or N (no)${NC}" >&2
                ;;
        esac
    done
}

# Download and execute migration
run_migration() {
    local version="$1"
    local migration_type="$2"  # "full" or "light"
    local temp_dir="/tmp/meowrch-update-$version"
    
    # Delete the old folder if it exists
    rm -rf "$temp_dir"
    mkdir -p "$temp_dir"
    
    log "üîÑ Checking update to version $version (type: $migration_type)..."
    
    # Getting the release data
    local release_data
    release_data=$(curl -s "$GITHUB_API_URL" | jq --arg version "v$version" --arg version_no_v "$version" '.[] | select(.tag_name == $version or .tag_name == $version_no_v)')
    
    if [[ -z "$release_data" || "$release_data" == "null" ]]; then
        error "Release version $version not found"
        rm -rf "$temp_dir"
        return 1
    fi
    
    if [[ "$migration_type" == "light" ]]; then
        # Light migration
        local migration_download_url
        migration_download_url=$(echo "$release_data" | jq -r --arg filename "migrate_to_${version}_light.py" '.assets[] | select(.name == $filename) | .browser_download_url')
        
        if [[ -z "$migration_download_url" || "$migration_download_url" == "null" ]]; then
            error "Light migration file migrate_to_${version}_light.py not found for version $version"
            rm -rf "$temp_dir"
            return 1
        fi
        
        log "üì• Downloading light migration file..."
        local migration_file="$temp_dir/migrate_to_${version}_light.py"
        if ! curl -L -s "$migration_download_url" -o "$migration_file"; then
            error "Failed to download light migration file"
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Showing the migration content to the user
        if ! show_migration_preview "$migration_file" "$version"; then
            warn "Migration cancelled by user"
            rm -rf "$temp_dir"
            return 1
        fi
        
        log "üîÑ Executing light migration to version $version..."
        
        # Performing migration
        if python3 "$migration_file"; then
            log "‚úÖ Light migration to version $version completed successfully"
            set_version "$version"
        else
            error "Light migration to version $version failed"
            rm -rf "$temp_dir"
            return 1
        fi
        
    else
        # Full migration
        local migration_download_url
        migration_download_url=$(echo "$release_data" | jq -r --arg filename "migrate_to_$version.py" '.assets[] | select(.name == $filename) | .browser_download_url')
        
        if [[ -z "$migration_download_url" || "$migration_download_url" == "null" ]]; then
            log "üìù Migration file migrate_to_$version.py not found for version $version"
            log "‚è≠Ô∏è Skipping this version (version NOT updated)"
            rm -rf "$temp_dir"
            return 0
        fi
        
        log "‚úÖ Found full migration file for version $version"
        
        # Getting the TAR.GZ URL of the release archive
        local tarball_url
        tarball_url=$(echo "$release_data" | jq -r '.tarball_url')
        
        if [[ -z "$tarball_url" || "$tarball_url" == "null" ]]; then
            error "TAR.GZ archive for version $version not found"
            rm -rf "$temp_dir"
            return 1
        fi
        
        log "üì¶ Downloading TAR.GZ archive of release $version..."
        local tar_file="$temp_dir/release.tar.gz"
        
        # Download from the progress bar if supported
        if [[ -t 2 ]]; then
            if ! curl -L --progress-bar "$tarball_url" -o "$tar_file"; then
                error "Failed to download TAR.GZ archive of release"
                rm -rf "$temp_dir"
                return 1
            fi
        else
            if ! curl -L -s "$tarball_url" -o "$tar_file"; then
                error "Failed to download TAR.GZ archive of release"
                rm -rf "$temp_dir"
                return 1
            fi
        fi
        
        log "üìÇ Extracting archive..."
        if ! tar -xzf "$tar_file" -C "$temp_dir"; then
            error "Failed to extract TAR.GZ archive"
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Find the extracted folder
        local extracted_dir
        extracted_dir=$(find "$temp_dir" -maxdepth 1 -type d -name "*meowrch*" ! -path "$temp_dir" | head -n1)
        
        if [[ -z "$extracted_dir" ]]; then
            error "Failed to find extracted release folder"
            ls -la "$temp_dir" >&2
            rm -rf "$temp_dir"
            return 1
        fi
        
        log "üîÑ Found extracted folder: $(basename "$extracted_dir")"
        mv "$extracted_dir" "$temp_dir/meowrch"
        
        log "üì• Downloading migration file..."
        local migration_file="$temp_dir/meowrch/migrate_to_$version.py"
        if ! curl -L -s "$migration_download_url" -o "$migration_file"; then
            error "Failed to download migration file"
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Showing the migration content to the user
        if ! show_migration_preview "$migration_file" "$version"; then
            warn "Migration cancelled by user"
            rm -rf "$temp_dir"
            return 1
        fi
        
        log "üîÑ Executing full migration to version $version..."
        
        # Go to the release folder to perform the migration
        cd "$temp_dir/meowrch" || {
            error "Failed to change to release folder"
            rm -rf "$temp_dir"
            return 1
        }
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –º–∏–≥—Ä–∞—Ü–∏—é
        if python3 "migrate_to_$version.py"; then
            log "‚úÖ Full migration to version $version completed successfully"
            set_version "$version"
        else
            error "Full migration to version $version failed"
            cd - > /dev/null
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Return to the original directory
        cd - > /dev/null
    fi
    
    rm -rf "$temp_dir"
    return 0
}


# Check if notification was shown for version
is_version_notified() {
    local version="$1"
    [[ -f "$NOTIFICATION_STATE" ]] && grep -q "^$version$" "$NOTIFICATION_STATE"
}

# Mark version as notified
mark_version_notified() {
    local version="$1"
    mkdir -p "$(dirname "$NOTIFICATION_STATE")"
    echo "$version" >> "$NOTIFICATION_STATE"
}

# Mark version as hidden (don't show notifications)
mark_version_hidden() {
    local version="$1"
    local hidden_file="$HOME/.local/state/meowrch-hidden"
    mkdir -p "$(dirname "$hidden_file")"
    echo "$version" >> "$hidden_file"
}

# Check if version is hidden by user
is_version_hidden() {
    local version="$1"
    local hidden_file="$HOME/.local/state/meowrch-hidden"
    [[ -f "$hidden_file" ]] && grep -q "^$version$" "$hidden_file"
}

# Start update in new terminal
open_update_terminal() {
    # Terminal list for Meowrch in order of preference
    local terminals=(
        "kitty"             # Main terminal in Meowrch
        "alacritty"         # Alternative modern
        "gnome-terminal"    # GNOME compatibility
        "xterm"             # Fallback
    )
    
    # Find available terminal
    local terminal_cmd=""
    local terminal_name=""
    for terminal in "${terminals[@]}"; do
        if command -v "$terminal" > /dev/null 2>&1; then
            terminal_name="$terminal"
            case "$terminal" in
                "kitty"|"alacritty")
                    terminal_cmd="$terminal -e"
                    ;;
                "gnome-terminal")
                    terminal_cmd="$terminal --"
                    ;;
                "xterm")
                    terminal_cmd="xterm -e"
                    ;;
            esac
            break
        fi
    done
    
    if [[ -z "$terminal_cmd" ]]; then
        error "No suitable terminal emulator found"
        log "üí° Run update manually: update-meowrch update"
        return 1
    fi
    
    log "üñ•Ô∏è Opening terminal for update ($terminal_name)..."
    
    # Create temporary script for nice terminal output
    local temp_script="/tmp/meowrch-update-terminal-$$"
    local script_path="$(which update-meowrch 2>/dev/null || echo "/usr/bin/update-meowrch")"
    
    # Use current script if not found in PATH
    if [[ "$script_path" == "/usr/bin/update-meowrch" ]] && [[ ! -f "$script_path" ]]; then
        script_path="${0}"
    fi
    
    # Escape script_path variable for use in heredoc
    local script_path_escaped="${script_path}"
    
    cat > "$temp_script" << 'EOF'
#!/bin/bash
set -e

# Update script path
SCRIPT_PATH="@SCRIPT_PATH@"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo -e "${CYAN}             üîÑ MEOWRCH SYSTEM UPDATE üîÑ${NC}"
echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo ""
echo -e "${YELLOW}Starting update process...${NC}"
echo ""

# Run update
if "${SCRIPT_PATH}" update; then
    echo ""
    echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${GREEN}             ‚úÖ UPDATE COMPLETED SUCCESSFULLY! ‚úÖ${NC}"
    echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    echo -e "${GREEN}üéâ Meowrch has been successfully updated!${NC}"
    echo -e "${YELLOW}üí° It's recommended to reboot the system to apply all changes${NC}"
else
    echo ""
    echo -e "${RED}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${RED}             ‚ùå UPDATE ERROR! ‚ùå${NC}"
    echo -e "${RED}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    echo -e "${RED}üí• An error occurred during update${NC}"
    echo -e "${YELLOW}üí° Check logs above or run '${SCRIPT_PATH} status' for diagnostics${NC}"
fi

echo ""
echo -e "${BLUE}Press Enter to close terminal...${NC}"
read

# Remove temporary script
rm -f "$0"
EOF
    
    # Replace @SCRIPT_PATH@ marker with real script path
    sed -i "s|@SCRIPT_PATH@|${script_path_escaped}|g" "$temp_script"
    
    chmod +x "$temp_script"
    
    # Run in background
    nohup $terminal_cmd bash "$temp_script" > /dev/null 2>&1 &
    
    log "‚úÖ Terminal with update started"
}

notify_user() {
    local latest_version="$1"
    local current_version="$2"
    
    # Determine icon
    local icon_arg=""
    if [[ -f "/usr/share/pixmaps/meowrch-logo.png" ]]; then
        icon_arg="-i /usr/share/pixmaps/meowrch-logo.png"
    else
        icon_arg="-i software-update-available"
    fi
    
    # Desktop notification with buttons
    if command -v notify-send > /dev/null 2>&1; then
        # Check action support in notify-send
        if notify-send --help 2>/dev/null | grep -q -- "--action"; then
            # Modern version with button support
            local result
            result=$(notify-send \
                --app-name="Meowrch" \
                "New version available!" \
                "Version $latest_version is ready to install.\nTo update run: update-meowrch update" \
                $icon_arg \
                --urgency="critical" \
                --expire-time=0 \
                --action="update=Update now" \
                --action="hide=Don't show again" \
                --action="later=Remind later" 2>/dev/null || echo "")
            
            # Handle user response
            case "$result" in
                "update")
                    log "üöÄ User started update from notification"
                    open_update_terminal
                    ;;
                "hide")
                    log "üîï User hid notifications for version $latest_version"
                    mark_version_hidden "$latest_version"
                    ;;
                "later"|"")
                    log "‚è∞ User postponed update"
                    ;;
            esac
        else
            # Simple notification without buttons
            notify-send \
                --app-name="Meowrch" \
                "üîÑ New Meowrch version!" \
                "Version $latest_version available (current: $current_version)\n\nTo update: update-meowrch update" \
                $icon_arg \
                --urgency="critical" \
                --expire-time=0
        fi
    fi
    
    log "üÜï New version available: $latest_version (current: $current_version)"
    log "üí° To update use: update-meowrch update"
}

check_update() {
    local current_version
    current_version=$(get_current_version)
    
    log "Checking for updates... (current version: $current_version)"
    
    local latest_with_migration
    latest_with_migration=$(get_latest_version_with_migration)
    
    if [[ -z "$latest_with_migration" ]]; then
        log "‚úÖ No updates available (no versions with migration files)"
        return 0
    fi
    
    # Only notify if there's a newer version available
    if version_gt "$latest_with_migration" "$current_version"; then
        # Check if version is hidden by user
        if is_version_hidden "$latest_with_migration"; then
            log "‚ÑπÔ∏è Notifications for version $latest_with_migration are hidden by user"
            return 0
        fi
        
        # Check if notification was already shown (but only if not hidden)
        if is_version_notified "$latest_with_migration"; then
            # Show notification again, as user didn't hide it
            log "üîÑ Showing repeated notification for version $latest_with_migration"
            notify_user "$latest_with_migration" "$current_version"
        else
            # First time showing notification
            log "üÜï Showing notification about new version $latest_with_migration"
            notify_user "$latest_with_migration" "$current_version"
            mark_version_notified "$latest_with_migration"
        fi
    else
        log "‚úÖ You have the latest available version ($current_version)"
    fi
}

# Show current version status
show_status() {
    local current_version
    current_version=$(get_current_version)
    local latest_version
    latest_version=$(get_latest_version)
    
    log "üìã Current version: $current_version"
    log "üìã Latest version on GitHub: $latest_version"
    
    # Showing the available migrations
    local available_versions
    available_versions=($(get_versions_with_migrations "$current_version"))
    
    if [[ ${#available_versions[@]} -gt 0 ]]; then
        log "üîÑ Available migrations:"
        for version in "${available_versions[@]}"; do
            local migration_type
            migration_type=$(get_migration_type "$version")
            log "   - $version ($migration_type)"
        done
        log "üí° To update use: update-meowrch update [version]"
    else
        log "‚úÖ You have the latest version with available updates"
    fi
    
    # Showing the update chain to the latest version
    local update_chain
    update_chain=($(get_versions_with_migrations "$current_version" "$latest_version"))
    if [[ ${#update_chain[@]} -gt 0 ]]; then
        local chain="$current_version"
        for version in "${update_chain[@]}"; do
            chain+=" ‚Üí $version"
        done
        log "üìà Update path to latest: $chain"
    fi
}

# Perform update
perform_update() {
    if [[ "$EUID" -eq 0 ]]; then
        error "This command cannot be run as root or with sudo privileges."
        error "Please run without sudo to update for your user account."
        exit 1
    fi

    while true; do
        echo -ne "${YELLOW}==> Are you sure you want to update? [Y/n]: ${NC}" >&2
        read -r response
        case "$response" in
            ""|[Yy]|[Yy][Ee][Ss])
                break
                ;;
            [Nn]|[Nn][Oo])
                echo -e "${RED}Update cancelled${NC}" >&2
                return 0
                ;;
            *)
                echo -e "${RED}Please enter Y (yes) or N (no)${NC}" >&2
                ;;
        esac
    done

    local target_version="${1:-}"  # Optional target version
    
    local current_version
    current_version=$(get_current_version)
    
    # Getting all versions with migrations from current to target
    local versions_to_update
    versions_to_update=($(get_versions_with_migrations "$current_version" "$target_version"))
    
    if [[ ${#versions_to_update[@]} -eq 0 ]]; then
        if [[ -n "$target_version" ]]; then
            warn "No available migrations from $current_version to $target_version"
        else
            warn "No available migrations from current version $current_version"
        fi
        return 0
    fi
    
    if [[ -n "$target_version" ]]; then
        log "üîÑ Updating from $current_version to $target_version via ${#versions_to_update[@]} step(s)"
    else
        log "üîÑ Updating from $current_version to latest version via ${#versions_to_update[@]} step(s)"
    fi
    
    log "üìã Update chain: ${versions_to_update[*]}"
    
    # We perform migrations in order
    for version in "${versions_to_update[@]}"; do
        local migration_type
        migration_type=$(get_migration_type "$version")
        
        if [[ -z "$migration_type" ]]; then
            error "No migration found for version $version"
            return 1
        fi
        
        log "üîú Next: $current_version ‚Üí $version ($migration_type migration)"
        
        if ! run_migration "$version" "$migration_type"; then
            error "‚ùå Migration to $version failed"
            return 1
        fi
        
        # Update the current version for the next iteration
        current_version="$version"
        log "‚úÖ Successfully updated to $version"
    done
    
    if [[ -n "$target_version" ]]; then
        log "üéâ Successfully updated from $current_version to $target_version"
    else
        log "üéâ Successfully updated to latest version $current_version"
    fi
}

# Main functionality
case "${1:-update}" in
    "check")
        check_update
        ;;
    "status")
        show_status
        ;;
    "update")
        perform_update "${2:-}"
        ;;
    "open-terminal")
        open_update_terminal
        ;;
    *)
        echo "Usage: update-meowrch [check|status|update|open-terminal] [version]"
        echo ""
        echo "Commands:"
        echo "  check              - Check for updates and show notification if available"
        echo "  status             - Show current version status and available migrations"
        echo "  update [version]   - Update to specific version or latest (chain migrations)"
        echo "  open-terminal      - Open update in new terminal window"
        echo ""
        echo "Examples:"
        echo "  update-meowrch update           # Update to latest version via chain"
        echo "  update-meowrch update 2.5.0     # Update to specific version 2.5.0"
        echo ""
        echo "Default command is 'check' when no arguments provided"
        ;;
esac
